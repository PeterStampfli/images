
<!DOCTYPE html>
<html lang="en">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

<head>
    <title> koch</title>
</head>

<body>


</body>



<script type='module'>

import {
    CoordinateTransform,
    ParamGui,
    output
} from "../libgui/modules.js";
// basic setup
const gui = new ParamGui({
    name: 'Kochflakes',
    closed: false
});
const canvasGui = gui.addFolder({
    name: 'image controls',
    closed: true
});
// an output canvas and some test image
output.createCanvas(canvasGui);
const canvas = output.canvas;
const canvasContext = output.canvasContext;
canvasGui.addTitle('coordinate transform');
output.showCanvasChanged = function() {};
output.setCanvasWidthToHeight();
output.addCoordinateTransform(canvasGui, false);
output.setInitialCoordinates(0, 0, 100);

const koch = {};
koch.nCorners = 5;
koch.m = 2;
koch.radius = 45;
koch.background = '#eeeeaa';
koch.linecolor = '#000066';
koch.lineWidth = 1;
koch.generations = 6;
koch.heightExtension = 1;
koch.widthExtension = 1;

gui.addParagraph('You can use the mouse wheel to change numbers.');
// controls
gui.addTitle('basic star polygon {p/q}:');

function defineLength() {
    const gamma = 2 * Math.PI / koch.nCorners * koch.m;
    const relativeLength = 0.5 / (1 + Math.cos(gamma / 2));
    outerControl.setValueOnly(relativeLength);
    innerControl.setValueOnly(relativeLength);
}

gui.add({
    type: 'number',
    params: koch,
    property: 'nCorners',
    step: 1,
    min: 3,
    labelText: 'p',
    onChange: function(value) {
      qController.uiElement.setMax(value-1);
        defineLength();
        draw();
    },
})
const qController=gui.add({
    type: 'number',
    params: koch,
    property: 'm',
    step: 1,
    min: 1,
    max:koch.nCorners-1,
    labelText: 'q',
    onChange: function() {
        defineLength();
        draw();
    },
})
gui.add({
    type: 'number',
    params: koch,
    property: 'radius',
    min: 10,
})


gui.addTitle('number of iterations');
gui.add({
    type: 'number',
    params: koch,
    property: 'generations',
    step: 1,
    min: 0,
    max: 7,
    labelText: '',
    onChange: function() {
        draw();
    },
})

const gamma = 2 * Math.PI / koch.nCorners * koch.m;
koch.outer = 0.5 / (1 + Math.cos(gamma / 2));;
koch.inner = koch.outer;

gui.addTitle('modification of the line lengths');

const outerControl = gui.add({
    type: 'number',
    params: koch,
    property: 'outer',
    step: 0.001,
    min: -1,
    max: 1,
    onChange: function() {
        draw();
    },
})

const innerControl = gui.add({
    type: 'number',
    params: koch,
    property: 'inner',
    step: 0.001,
    min: -1,
    max: 1,
    onChange: function() {
        draw();
    },
})

gui.addTitle('styling');
gui.add({
    type: 'number',
    params: koch,
    property: 'lineWidth',
    min: 1,
    labelText: 'width of line',
    onChange: function() {
        draw();
    },
})
gui.add({
    type: 'color',
    params: koch,
    property: 'background',
    onChange: function() {
        draw();
    }
});
gui.add({
    type: 'color',
    params: koch,
    property: 'linecolor',
    onChange: function() {
        draw();
    }
});


// define the triangle
var relativeLength; // length of the sides of thenew generation as a fraction of the length of the previous generation
var relativeHeight; // height of the added triangles as a fraction of the side length of the previous generation

function line(generation, ax, ay, bx, by) {
    if (generation <= 0) {
        canvasContext.beginPath();
        canvasContext.moveTo(ax, ay);
        canvasContext.lineTo(bx, by);
        canvasContext.stroke();
    } else {
        generation--;
        const cx = 0.5 * (ax + bx);
        const cy = 0.5 * (ay + by);
        const px = cx + relativeHeight * (by - ay);
        const py = cy - relativeHeight * (bx - ax);
        const aax = ax + relativeLength * (bx - ax);
        const aay = ay + relativeLength * (by - ay);
        const bbx = bx + relativeLength * (ax - bx);
        const bby = by + relativeLength * (ay - by);
        line(generation, ax, ay, aax, aay);
        line(generation, aax, aay, px, py);
        line(generation, px, py, bbx, bby);
        line(generation, bbx, bby, bx, by);
    }
}

function draw() {
    // setting up the canvas
    output.updateTransform();
    output.setLineWidth(koch.lineWidth);
    output.clearCanvas();
    canvasContext.strokeStyle = koch.linecolor;
    canvas.style.backgroundColor = koch.background;
    // general parameters
    const gamma = 2 * Math.PI / koch.nCorners * koch.m;
    relativeLength = koch.outer;
    relativeHeight = Math.sqrt(Math.max(0, koch.inner * koch.inner - (0.5 - koch.outer) * (0.5 - koch.outer)));
    if (koch.inner < 0) {
        relativeHeight *= -1;
    }
    for (var i = 0; i < koch.nCorners; i++) {
        let angle = gamma * i;
        const ax = koch.radius * Math.cos(angle);
        const ay = koch.radius * Math.sin(angle);
        angle += gamma;
        const bx = koch.radius * Math.cos(angle);
        const by = koch.radius * Math.sin(angle);
        line(koch.generations, ax, ay, bx, by);
    }
}

output.showCanvasChanged = draw;
draw();

</script>

</html>